package com.example.multithreading;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultithreadingPart6 {
    /*
    CountDownLatch - це механізм синхронізації, який доступний в деяких мовах програмування, таких як Java. Він
    використовується для керування потоками і забезпечення синхронізації між ними. CountDownLatch дозволяє одному або
    більше потокам чекати, доки інші потоки не виконають певну кількість операцій.

    CountDownLatch працює на основі лічильника. При створенні CountDownLatch вказується початкова кількість "операцій"
    (count), яку потрібно виконати перед тим, як потоки, що чекають, будуть відпущені. Коли потік виконує одну операцію,
    він викликає метод countDown() CountDownLatch, що зменшує значення лічильника. Потоки, які чекають на CountDownLatch,
    можуть викликати метод await(), який блокує їх до тих пір, поки лічильник не стане рівним нулю.

    Основне використання CountDownLatch полягає в тому, щоб дочекатися закінчення певних дій або подій перед продовженням
    виконання коду. Наприклад, якщо у вас є основний потік, який очікує на завершення декількох фонових потоків перед
    продовженням виконання, ви можете використовувати CountDownLatch для синхронізації цих потоків. Кожен фоновий потік
    викликає countDown() після закінчення своїх операцій, а головний потік викликає await(), щоб заблокуватися до
    завершення всіх фонових потоків.

    CountDownLatch є потужним інструментом для управління потоками і забезпечення послідовності виконання коду у
    мультипоточних програмах. Він дозволяє зменшити кількість використаних блокувань і надає можливість ефективно
    використовувати ресурси системи.
     */

    /*
    У Spring Boot або Spring Framework загалом CountDownLatch може бути корисним для вирішення різних сценаріїв, таких як:

    1. Очікування завершення запуску декількох фонових служб або процесів, перш ніж продовжити виконання основного додатку
        Spring Boot.

    2. Координація паралельної обробки даних, коли декілька потоків виконують обчислення над окремими частинами даних,
        а потім головний потік очікує, доки всі обчислення не будуть завершені, перед тим як об'єднати результати.

    3. Виконання послідовних етапів запуску додатку, де кожен етап може виконуватись у власному потоці, але потребує
        завершення попереднього етапу перед продовженням.

    Хоча Spring Boot надає більш високорівневі механізми синхронізації та управління потоками, такі як анотації @Async
    та @EnableAsync, що дозволяють використовувати асинхронне програмування та пул потоків, CountDownLatch може бути
    використаний у випадках, коли потрібні більш низькорівневі механізми контролю потоків.

    Важливо враховувати, що використання CountDownLatch пов'язане з ручним керуванням потоками, і неправильне використання
    може призвести до блокування програми або інших проблем з потоками. При використанні CountDownLatch рекомендується
    ретельно розробляти логіку синхронізації та впевнитися, що лічильник буде правильно зменшений у всіх сценаріях виконання.

     */

    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(3);
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 3; i++) {
            executorService.execute(new Processor6(latch));
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        executorService.shutdown();

        System.out.println("Completed");
    }

}

class Processor6 implements Runnable {
    private CountDownLatch latch;

    public Processor6(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        System.out.println("Processor is started");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        latch.countDown();
    }
}